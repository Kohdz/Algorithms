# 3. Swap Bits. Swap the 1-index bit


def swap_bits(x):

    pass


i = 1
j = 6
x = 0b01001001  # 00001011
print(swap_bits(x, i, j))

# 4. Write a program that takes a 64-th bit unsigned integer and returns the 64-bit unsigned
# integer consisting of the bits of the input in reverse order.  For example, the input is
# (1110000000000001), the output should be (1000000000000111).

#       x = 0b1110000000000001 #1000000000000111

# 5. Define the weight of a nonnegative integer x to be the number of bits that are set to 1
# in its binary representation.  For example, since 92 in base-2 equals (1011100), the weight
# of 92 is 4.  Write a program which takes as input a nonnegative integer x and returns a
# number y which is not equal to x, but has the same weight as x and their difference, |y - x|,
# is as small as possible.  You can assume x is not 0, or all 1s.  For example, if x = 6,
# you should return 5.  You can assume the integer fits in 64 bits.

#       x = 6 #5

#  5. Write a program that multiplies two nonnegative integers.  The only operators you are
#  allowed to use are
#     - assignment
#     - the bitwise operators >>, <<, |, &, ~, ^, and
#     - equality checks and Boolean combinations thereof

#       x = 3
#       y = 2

# 6. given two postive integers, compute their quotient, using only the addition, subtraction
# and shifting operators
# relate x/y to (x-y)/y

#       x = 10
#       y = 3

# 7. Write a program that takes a doube x and an integer y and returns x^y, You can ignore overflow
# and underflow

#       x = 2
#       y = 2

# 8.  Write a program which takes an integer and return the integer corresponding to the digits of the
# input written in reverse order.  For example, the reverse of 42 is 24, and the reverse of -314 is -413.

# 9.  Write a program that takea an integer and determines if that integer representation as a decimal string
# is a palindrome.  For example 121 is is a palindrome; 7 is a palindrome; -1 is not

#       x = 1221
